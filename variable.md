# ICP Variable Extension

The main aim of this extension is provide usable and powerful interface for working with variables on ICP server

## Getting, Setting and subcribing changes

This extension can get and send variables, also there are ability to subscribe changes. Here is basic example

```
# Server
server = new TcpICPServer()
variable = new LocalVariable('/var', 10)

# Client
connection = new TcpICPConnection()

variable = new RemoteVariable(connection, '/var')

variable.onChange(function callback(val){
  print('Variable changed to: ' + val)

})

variable.get() # Get variable
variable.set(70) # Set it to 70

```

Note: on change handler will be called ONCE if you want to subscribe each change you need after every change subscribe again

## What happens inside

Here is example communication generated by previsios program

```json
// -> to server
// <- from server
-> {"type": "subscribe", "endpoint": "/var", "id": 1}
-> {"type": "get", "endpoint": "/var", "id": 2}
<- {"type": "ok", "id": 2, "value": 10}
-> {"type": "set", "endpoint": "/var", "id": 3, "value": 70}
<- {"type": "publish", "id": 1, "value": 70}
<- {"type": "ok", "id": 3}
```

Variable extension provide 3 types:

- get - for getting variable value
- set - for setting variable value
- subscribe - for subcribing variable changes

Also there are 3 types for replying

- ok - when request was to get/set and it was successful
- error - when request fails, for example when access denied
- publish - reply to subscribe when variable change

The real value always sended using property value

How to encode:

- get request is basic request to endpoint of Variable and type get
- get reply is basic reply with value property which contains value of variable and status ok
- set request is basic request to endpoint of Variable with property value which contains value to set on and status set
- set reply is basic reply with status ok
- subscribe request is basic request with type subscribe
- subscribe reply is basic reply with type publish and value that contains variable value
- error reply is basic reply with type error, code whic contains code of error, and msg which contains description of error

## Note about wildcard paths

ICP realization adds feature of wildcard paths, so Variable Extension handles it, for each different endpoint variable will be different, for example

```
# Server
server = new TcpICPServer()
online = new LocalVariable('/user/:id/online', false)

# Client
connection = new TcpICPConnection()

userA = new RemoteVariable(connection, '/user/A/online')

userB = new RemoteVariable(connection, '/user/B/online')

userA.get()
userB.get()
# At strat both users are false

userA.set(true) # Change user A online to true

userA.get()
userB.get()
# Now userA is true, but user B is still false
```

# Send handlers

Both implementations should have callback, which should be called before message sent, for example for adding parameters such as session, rate limits and callback which should be called when get request from client for server or when get reply from server for client, is needed for auth, for example let's say we have variable /user/a/online and /user/b/online, so it is easy to understand that user A can change /user/b/online so we need to add function that don't allow that:

```
# Server
server = new TcpICPServer()
online = new LocalVariable('/user/:id/online', false)

online.before(function(msg, continue, reply){
  user = msg["endpoint"].split('/')[1] # Get part :id
  session = getSession(msg).id # Extract id from session
  if (user == session)
    continue() # User tries to set his online all is ok, continue
   else
     reply({ type: "error", code: 2, msg: "Access denied"}) # User tries to set not his online reply with error
})

# Client
connection = new TcpICPConnection()

userA = new RemoteVariable(connection, '/user/A/online')

userB = new RemoteVariable(connection, '/user/B/online')

userA.get()
userB.get()
# At strat both users are false

userA.set(true) # Change user A online to true
userB.set(true) # Should throw error and not change status

userA.get()
userB.get()
# Now userA is true, but user B is still false
```

## Recommended implementation

Both of LocalVariable and RemoteVariable should have next methods:

- get - should return value of variable
- set - should set variable to new value which accepts
- onChange - accepts callback which should be called when value changes
- before - before sending message
- after - when getting message
- doc - documentate message

```
class LocalVariable (server, endpoint, initialValue) {
  values = new Map()
  beforeCallback = function(msg, write, continue){continue(msg)}
  afterCallback = function(msg, write){write(msg)}
  subscribers = new Map(new Array)

  server.subscribe(endpoint, function(msg, dWrite){
    write = function(msg) {
		afterCallback(msg, dWrite)
	}
	beforeCallback(msg, write, function(msg) {
      repl = {}
      if(msg["type"] == "get") {
		write({
		  "type": "ok",
		  "value": values.get(msg["endpoint"])
		})
	  }  else if (msg["type"] == "set") {
	    subscribers.get(msg["endpoint"]).forEach(call e)
        values.set(msg["endpoint"], msg["value"])
        write({
		  "type": "ok"
		})
	  } else if (msg["type"] == "subscribe") {
		 subscribers.get(msg["endpoint"]).push(function(val) {
		  write({
            "type": "publish",
            "value": val
	      })
		})
	  } else {
		write({
		  "type": "error",
		  "code": 1,
		  "msg": "Incoreect type"
		})
	  }
	})

  })

  get(endpoint) {
    if(endpoint)
      return values[0].value
    else
      return values.get(endpoint)
  }

   set(endpoint, value) {
    if(endpoint)
      return values[0].value = value
    else
      return values.set(endpoint, value)
  }

  onChange(endpoint, callback) {
    if(endpoint)
      return subscribers[0].value.push(callback)
    else
      return subscribers.get(endpoint).push(callback)
  }
}

class RemoteVariable (connection, endpoint) {
  beforeCallback = function(msg, write, continue){continue(msg)}
  afterCallback = function(msg, write){write(msg)}

  get(callback) {
    connection.send({
      "type": "get"
    }, function(e){
      if(e["type"] == "ok")
        callback(e["value"])
      else
        throw new Error(e["code"] + ": " + e["msg"])
    })
  }

   set(value, callback) {
    connection.send({
      "type": "set",
      "value": value
    }, function(e){
      if(e["type"] == "ok")
        callback()
      else
        throw new Error(e["code"] + ": " + e["msg"])
    })
  }

  onChange(callback) {
    connection.send({
      "type": "subscribe"
    }, function(e){
      if(e["type"] == "publish")
        callback(e["value"])
      else
        throw new Error(e["code"] + ": " + e["msg"])
    })
  }
}

```
